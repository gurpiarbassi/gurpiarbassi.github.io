---
layout: post
title: "Understanding JSON Web Tokens (JWT)"
published: true
date: 2025-09-08
categories: security authentication
---

# Motivation

In this post, we'll explore JSON Web Tokens (JWTs) - a modern approach to authentication that's become essential for building scalable APIs and microservices.

## What is a JWT?

A JSON Web Token (JWT) is a compact, URL-safe token used to securely transmit information between parties. Unlike traditional session-based authentication, JWTs are **stateless** - all necessary user information is stored within the token itself.

### Key Benefits

- **Stateless**: No server-side session storage required
- **Scalable**: Perfect for distributed systems and microservices
- **Self-contained**: User claims are embedded in the token
- **Cross-domain**: Works well across different domains
- **Performance**: Signature verification is faster than database lookups

## JWT Structure

A JWT consists of three parts separated by dots:

```
header.payload.signature
```

### 1. Header

Contains metadata about the token:

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

- `alg`: Signing algorithm (HS256, RS256, etc.)
- `typ`: Token type (always "JWT")

### 2. Payload

Contains the claims (user data). Three types of claims:

**Registered Claims** (predefined):
- `iss`: Issuer (who issued the token)
- `sub`: Subject (who the token refers to, often the user ID)
- `aud`: Audience (who the token is intended for)
- `exp`: Expiration time (when the token expires)
- `nbf`: Not before (token becomes valid after this time)
- `iat`: Issued at (when the token was created)
- `jti`: Token ID (unique identifier to prevent reuse)

**Public Claims**: Custom claims in public namespace

**Private Claims**: Custom claims agreed upon by parties

Example payload:
```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true,
  "iat": 1516239022,
  "exp": 1516242622
}
```

### 3. Signature

Created by signing the header and payload with a secret:

```
HMACSHA256(
  base64UrlEncode(header) + "." + base64UrlEncode(payload),
  secret
)
```

## Who Signs the JWT?

The JWT is signed by the **authentication server** or **authorization server** that issues the token. This is typically:

- **Your application's backend server** (for self-hosted authentication)
- **Identity providers** like Auth0, AWS Cognito, or Firebase Auth
- **OAuth providers** like Google, Facebook, or Microsoft
- **Enterprise identity systems** like Active Directory or LDAP

### Signing Process

1. **Server generates the token** with user claims
2. **Server signs the token** using a secret key (HS256) or private key (RS256)
3. **Server sends the signed token** to the client
4. **Client stores and sends the token** with subsequent requests
5. **Server verifies the signature** to ensure token authenticity

### Key Points

- Only the **issuing server** has the secret/private key to sign tokens
- **Client applications** can only verify tokens, not create them
- The signature proves the token came from a trusted source
- If the secret is compromised, attackers can forge tokens

## Session Data vs JWT Claims

In traditional session-based authentication, we stored various user data on the server. With JWTs, we can move much of this data into the token itself as claims.

### What We Used to Store in Sessions

**User Identity Information:**
- User ID
- Username/email
- Full name
- Profile picture URL
- Account status (active, suspended, etc.)

**Authorization Data:**
- User roles (admin, user, moderator)
- Permissions (read, write, delete)
- Feature flags (premium user, beta access)
- Organization/tenant ID

**Session Metadata:**
- Login timestamp
- Last activity time
- IP address
- User agent
- Session expiration

**Application-Specific Data:**
- Shopping cart contents
- User preferences
- Language settings
- Timezone
- Theme preferences

### What Can Be Stored as JWT Claims

** Good for JWT Claims:**
```json
{
  "sub": "user123",
  "name": "John Doe",
  "email": "john@example.com",
  "roles": ["user", "premium"],
  "permissions": ["read", "write"],
  "org_id": "company456",
  "premium": true,
  "language": "en",
  "timezone": "UTC",
  "iat": 1516239022,
  "exp": 1516242622
}
```

** Avoid in JWT Claims:**
- Large data objects (shopping cart with 100+ items)
- Frequently changing data (last activity timestamp)
- Sensitive information (passwords, credit cards)
- Data that needs immediate updates (real-time status)

### Migration Strategy

**Phase 1: Core Identity**
```json
{
  "sub": "user123",
  "name": "John Doe",
  "email": "john@example.com",
  "roles": ["user"]
}
```

**Phase 2: Add Permissions**
```json
{
  "sub": "user123",
  "name": "John Doe",
  "email": "john@example.com",
  "roles": ["user"],
  "permissions": ["read", "write"],
  "org_id": "company456"
}
```

**Phase 3: Application Preferences**
```json
{
  "sub": "user123",
  "name": "John Doe",
  "email": "john@example.com",
  "roles": ["user"],
  "permissions": ["read", "write"],
  "org_id": "company456",
  "language": "en",
  "timezone": "UTC",
  "theme": "dark"
}
```

### Benefits of Moving to JWT Claims

1. **Reduced Database Queries** - No need to fetch user data on every request
2. **Better Performance** - Claims are available immediately after token verification
3. **Simplified Architecture** - No shared session storage required
4. **Microservices Friendly** - Each service can read claims without external calls

### Considerations

- **Token Size** - Keep claims minimal to avoid large tokens
- **Security** - Remember claims are Base64Url-encoded, not encrypted
- **Freshness** - Some data may need to be fetched from database if it changes frequently
- **Revocation** - JWT claims can't be updated until token expires

## How JWT Authentication Works

### Step 1: User Login
```http
POST /login
{
  "email": "user@example.com",
  "password": "password123"
}
```

### Step 2: Server Generates JWT
```javascript
const token = jwt.sign(
  { userId: 123, role: 'admin' },
  SECRET_KEY,
  { expiresIn: '1h' }
);
```

### Step 3: Client Stores Token
- Web apps: localStorage, sessionStorage, or HttpOnly cookies
- Mobile apps: Secure storage (Keychain, Keystore)

### Step 4: Client Sends Token
```http
GET /api/dashboard
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### Step 5: Server Verifies Token
1. Extract token from Authorization header
2. Verify signature and expiration
3. Grant access if valid

## Security Best Practices

### 1. **Use HTTPS Only**
Never transmit JWTs over unencrypted connections.

### 2. **Keep Secrets Secure**
- Use strong, randomly generated secret keys
- Never expose private keys in client code or version control
- Rotate keys regularly

### 3. **Choose Strong Algorithms**
- Use HS256, RS256, or ES256
- **Never use `alg: "none"`** - this disables signature verification

### 4. **Validate All Claims**
```javascript
jwt.verify(token, secret, {
  audience: 'your-app',
  issuer: 'trusted-issuer',
  algorithms: ['HS256']
});
```

### 5. **Set Short Expiration Times**
- Access tokens: 15-30 minutes
- Use refresh tokens for longer sessions

### 6. **Don't Store Sensitive Data**
JWT payloads are Base64Url-encoded, not encrypted. Anyone can decode them.

### 7. **Handle Token Revocation**
Since JWTs are stateless, consider:
- Short expiration times
- Refresh token rotation
- Token blacklists for critical revocations

## JWT Revocation Strategies

While JWTs are stateless by design, there are several approaches to handle revocation in case of security breaches:

### 1. **Short Token Expiration + Refresh Tokens**
```javascript
// Access token expires quickly
const accessToken = jwt.sign(payload, secret, { expiresIn: '15m' });

// Refresh token stored securely on server
const refreshToken = jwt.sign({ userId }, secret, { expiresIn: '7d' });
```

**Benefits:**
- Limits exposure window to 15 minutes
- Refresh tokens can be revoked immediately
- Minimal server-side state

### 2. **Token Blacklist**
```javascript
// Store revoked token IDs
const blacklist = new Set();

// Check if token is blacklisted
function isTokenBlacklisted(jti) {
  return blacklist.has(jti);
}

// Revoke token
function revokeToken(jti) {
  blacklist.add(jti);
}
```

**Benefits:**
- Immediate revocation capability
- Can target specific tokens

**Drawbacks:**
- Requires server-side storage
- Adds complexity to verification

### 3. **Key Rotation**
```javascript
// Rotate signing keys
const oldKey = 'old-secret';
const newKey = 'new-secret';

// All tokens signed with old key become invalid
```

**Benefits:**
- Invalidates all tokens at once
- Good for major security incidents

**Drawbacks:**
- Affects all users
- Requires coordinated deployment

### 4. **Hybrid Approach: Access + Refresh Tokens**
```javascript
// Short-lived access token
const accessToken = jwt.sign(
  { userId, jti: uuid() }, 
  secret, 
  { expiresIn: '15m' }
);

// Long-lived refresh token (stored in database)
const refreshToken = {
  id: uuid(),
  userId: userId,
  expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
  revoked: false
};
```

**Benefits:**
- Best of both worlds
- Immediate revocation of refresh tokens
- Limited exposure window for access tokens

### 5. **Real-time Validation**
```javascript
// Check token against user status
async function validateToken(token) {
  const decoded = jwt.verify(token, secret);
  
  // Check if user account is still active
  const user = await getUserById(decoded.userId);
  if (!user.active) {
    throw new Error('User account deactivated');
  }
  
  return decoded;
}
```

**Benefits:**
- Can revoke based on user status
- No token blacklist needed

**Drawbacks:**
- Requires database call on every request
- Defeats stateless nature of JWTs

### 6. **Event-Driven Revocation**
```javascript
// Publish revocation events
eventBus.publish('user.revoked', { userId, reason: 'breach' });

// Services listen and update their blacklists
eventBus.subscribe('user.revoked', (event) => {
  blacklist.add(event.userId);
});
```

**Benefits:**
- Immediate propagation across services
- Good for microservices architecture

### Recommended Approach

For most applications, use **short expiration + refresh tokens**:

```javascript
// 15-minute access tokens
const accessToken = jwt.sign(payload, secret, { expiresIn: '15m' });

// 7-day refresh tokens (stored in database)
const refreshToken = await createRefreshToken(userId);

// Immediate revocation
await revokeRefreshToken(refreshTokenId);
```

This provides:
- Limited exposure window (15 minutes)
- Immediate revocation capability
- Minimal server-side state
- Good security posture

## Common Pitfalls

###  Storing Sensitive Data
```json
{
  "userId": 123,
  "password": "secret123",  // Never do this!
  "creditCard": "4111..."
}
```

### Long Expiration Times
```javascript
// Too long - security risk
{ expiresIn: '30d' }

// Better
{ expiresIn: '15m' }
```

### Not Validating Claims
```javascript
// Insecure - doesn't validate audience or issuer
jwt.verify(token, secret)
```

## When to Use JWTs

### Good Use Cases
- Stateless APIs
- Microservices authentication
- Single Sign-On (SSO)
- Mobile app authentication
- Cross-domain authentication

### Avoid When
- You need immediate token revocation
- Storing large amounts of user data
- Simple single-server applications
- When session-based auth is sufficient

## Summary

JWTs provide a modern, scalable approach to authentication that's perfect for distributed systems. Key takeaways:

1. **Stateless by design** - no server-side session storage
2. **Self-contained** - user claims embedded in token
3. **Secure when implemented correctly** - always validate signatures and claims
4. **Not a silver bullet** - consider your specific use case

Remember: JWTs are powerful but require careful implementation to maintain security. Always follow security best practices and validate everything!